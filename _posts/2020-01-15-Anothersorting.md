---
layout : post
title : "2. 분할정복 알고리즘 (5) 기타 & 정렬 알고리즘 정리"
description :
date : 2020-01-15
category : Algorithms
tags : [Algoritms, Heapsort]
use_math: true
comments : true
share : true



---

<br/>
Sanjoy Dasgupta가 저술한 책인 Algorithms과 [이기창님의 블로그](https://ratsgo.github.io/), [Heee님의 블로그](https://gmlwjd9405.github.io/)를 참고하였다.

<br/>

### 그 밖의 정렬 알고리즘

다른 정렬 알고리즘을 간단하게 살펴보자

<br/>

#### 1-1. Insertion Sort(삽입 정렬)

배열의 모든 요소를 앞에서부터 차례대로, **이미 정렬된 (앞의) 배열부분과 비교하여 자신의 위치를 찾아 삽입**하며 정렬을 완성하는 알고리즘

방법 : **두 번째 요소**부터 시작해 앞의 배열부분과 비교해 정렬...$n$번째 요소와 $(n-1)$번째 요소를 비교해 정렬

다음 데이터의 배열로 예를 들어보자

> 5, 2, 4, 6, 1, 3

2를 꺼내서 앞에 이미 정렬된 배열부분(5)과 비교한다. 5>2 이므로 자리를 바꿔준다

> 2, 5, 4, 6, 1, 3

4를 꺼내서 앞의 이미 정렬된 배열부분(2, 5)과 비교한다. 먼저 5와 비교하고, 5>4 이므로 자리를 바꿔준다. 그 뒤, 2와 비교하고, 4>2 이므로 그대로 둔다. 이 과정을 쭉 반복하면 다음과 같이 정렬을 완성할 수 있다.

> 2, 4, 5, 6, 1, 3　...　2, 4, 5, 6, 1, 3　...　1, 2, 4, 5, 6, 3　...　1, 2, 3, 4, 5, 6

<br/>

#### 1-2. Insertion Sort의 특징

- **Stable 하다.**
- **In-place 하다.**

<br/>

#### 1-3. Insertion Sort의 시간복잡도

- Best, Average Case

  요소를 선택해 앞의 배열부분과 비교할 때 이동 없이 1번만 비교하면 되는 경우

  이 경우 비교하는 시간이 $O(1)$, 요소가 $n$개 이므로 시간복잡도는 $O(n)$

- Worst Case

  요소를 선택해 앞의 배열부분과 비교할 때 앞의 모든 배열부분과 비교해야 하는 경우

  > ex) 8, 7, 6, 5, 4, 3, 2, 1 ---> 두번째 요소 7부터 앞의 8과 비교해 바꿔주고, 그 다음 요소 6을 앞의 7, 8과 비교해 바꿔주고, 그 다음 요소 5를 앞의 8, 7, 6과 비교해 바꿔주고... 끔찍

  따라서 비교하는 시간은 $O(1)$ 이지만, 요소가 $n$개 일 때 앞의 모든 배열부분과 비교를 하게 되면 두번째 인덱스 요소는 1번, 세번째 인덱스 요소는 2번 ... $n$번째 인덱스 요소는 $n-1$번 비교하므로  $(1 + 2 + 3 + ... + n-1) = \frac {n(n-1)} 2 = O(n^2)$

<br/>



#### 2-1. Bubble Sort(버블 정렬)

서로 인접한 두 원소를 비교하여 크기 순서대로 정렬하는 알고리즘

방법 : 첫번째 요소와 두번째 요소 비교해 정렬... $(n-1)$번째 요소와 $n$번째 요소를 비교해 정렬. 이렇게 되면 가장 큰 값이 맨 뒤로 이동하게 된다. 그 다음, 맨 뒤 값을 제외하고 다시 위 과정을 반복

cf) 선택 정렬이 두번째 요소와 첫번째 요소, 세번째 요소와 첫, 두번째 요소... 순으로 비교하는 거라면, 버블 정렬은 첫번째 요소와 두번째 요소, 두번째 요소와 세번째 요소...순으로 비교한다.

다음 데이터의 배열로 예를 들어보자. 

> 4, 3, 5, 2

4와 3을 비교한다. 4 > 3 이므로 바꿔준다.

> 3, 4, 5, 2

4와 5를 비교한다. 5 > 4 이므로 그대로 둔다. 그 다음, 5와 2를 비교한다. 5 > 2 이므로 바꿔준다.

> 3, 4, 2, 5

가장 큰 값인 5가 맨 뒤에 위치하게 되었다. 이제 이 값을 제외하고 다시 위 과정을 반복한다. 그러면 결과는 다음과 같다.

> 3, 4, 2, 5 　...　3, 2, 4, 5　...　(2회전 끝. 다시 반복)　2,





<br/>

#### 2-2. Bubble Sort의 특징

<br/>

#### 2-3. Bubble Sort의 시간복잡도

<br/>



#### 2-1. Selection Sort(선택 정렬)

<br/>

#### 2-2. Selection Sort의 특징

<br/>

#### 2-3. Selection Sort의 시간복잡도

<br/>





### 3. Sorting Algorithms 총 정리



















